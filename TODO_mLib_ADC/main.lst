   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	USART_Init
  12               	USART_Init:
  13               	.LFB0:
  14               		.file 1 "main.c"
   1:main.c        **** // device: 	AtMega 328p
   2:main.c        **** // author:  Maciej Mielcarski
   3:main.c        **** // adc
   4:main.c        **** 
   5:main.c        **** #include <avr/io.h>
   6:main.c        **** #include <avr/interrupt.h>
   7:main.c        **** 
   8:main.c        **** #define F_CPU 16000000UL
   9:main.c        **** #define TIM1_PSC 1024		// TIMER 1 prescaler value
  10:main.c        **** #define TIM1_FREQ 1			// TIMER 1 desired frequency in seconds
  11:main.c        **** #define FOSC 16000000UL
  12:main.c        **** #define BAUD 9600
  13:main.c        **** #define MYUBRR FOSC/16/BAUD-1
  14:main.c        **** 
  15:main.c        **** #define SUPPLY_VOLT 5000	// [mV]
  16:main.c        **** #define ADC_RES 1024
  17:main.c        **** 
  18:main.c        **** #include <util/setbaud.h>
  19:main.c        **** 
  20:main.c        **** // ------------------------- UART ----------------------------------------
  21:main.c        **** 
  22:main.c        **** void USART_Init(unsigned int ubrr)		
  23:main.c        **** {
  15               		.loc 1 23 0
  16               		.cfi_startproc
  17               	.LVL0:
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  24:main.c        ****    UBRR0H = (unsigned char)(ubrr>>8);	// set baud rate to 9600
  22               		.loc 1 24 0
  23 0000 9093 C500 		sts 197,r25
  25:main.c        ****    UBRR0L = (unsigned char)ubrr;		//
  24               		.loc 1 25 0
  25 0004 8093 C400 		sts 196,r24
  26:main.c        ****    UCSR0B = (1<<RXEN0)|(1<<TXEN0);		// Enable receiver and transmitter 
  26               		.loc 1 26 0
  27 0008 88E1      		ldi r24,lo8(24)
  28               	.LVL1:
  29 000a 8093 C100 		sts 193,r24
  27:main.c        ****    UCSR0C = (1<<USBS0)|(3<<UCSZ00);		// Set frame format: 8data, 2stop bit
  30               		.loc 1 27 0
  31 000e 8EE0      		ldi r24,lo8(14)
  32 0010 8093 C200 		sts 194,r24
  33 0014 0895      		ret
  34               		.cfi_endproc
  35               	.LFE0:
  37               	.global	uart_putchar
  39               	uart_putchar:
  40               	.LFB1:
  28:main.c        **** }
  29:main.c        **** 
  30:main.c        **** void uart_putchar(char c) 
  31:main.c        **** {
  41               		.loc 1 31 0
  42               		.cfi_startproc
  43               	/* prologue: function */
  44               	/* frame size = 0 */
  45               	/* stack size = 0 */
  46               	.L__stack_usage = 0
  47               	.LVL2:
  48               	.L3:
  32:main.c        **** 	while ( !(UCSR0A & (1<<UDRE0)) )	// Wait for empty transmit buffer 
  49               		.loc 1 32 0 discriminator 1
  50 0016 9091 C000 		lds r25,192
  51 001a 95FF      		sbrs r25,5
  52 001c 00C0      		rjmp .L3
  33:main.c        **** 	;
  34:main.c        ****     UDR0 = c;							// Put data into buffer, sends the data 
  53               		.loc 1 34 0
  54 001e 8093 C600 		sts 198,r24
  55 0022 0895      		ret
  56               		.cfi_endproc
  57               	.LFE1:
  59               	.global	uart_getchar
  61               	uart_getchar:
  62               	.LFB2:
  35:main.c        **** }
  36:main.c        **** 
  37:main.c        **** char uart_getchar(void) {
  63               		.loc 1 37 0
  64               		.cfi_startproc
  65               	/* prologue: function */
  66               	/* frame size = 0 */
  67               	/* stack size = 0 */
  68               	.L__stack_usage = 0
  69               	.L8:
  38:main.c        ****     loop_until_bit_is_set(UCSR0A, RXC0); 	// Wait until data exists
  70               		.loc 1 38 0 discriminator 1
  71 0024 8091 C000 		lds r24,192
  72 0028 87FF      		sbrs r24,7
  73 002a 00C0      		rjmp .L8
  39:main.c        ****     return UDR0;
  74               		.loc 1 39 0
  75 002c 8091 C600 		lds r24,198
  40:main.c        **** }
  76               		.loc 1 40 0
  77 0030 0895      		ret
  78               		.cfi_endproc
  79               	.LFE2:
  81               	.global	uart_putstring
  83               	uart_putstring:
  84               	.LFB3:
  41:main.c        **** 
  42:main.c        **** void uart_putstring(char tab[])
  43:main.c        **** {
  85               		.loc 1 43 0
  86               		.cfi_startproc
  87               	.LVL3:
  88 0032 CF93      		push r28
  89               	.LCFI0:
  90               		.cfi_def_cfa_offset 3
  91               		.cfi_offset 28, -2
  92 0034 DF93      		push r29
  93               	.LCFI1:
  94               		.cfi_def_cfa_offset 4
  95               		.cfi_offset 29, -3
  96               	/* prologue: function */
  97               	/* frame size = 0 */
  98               	/* stack size = 2 */
  99               	.L__stack_usage = 2
 100               	.L11:
  44:main.c        **** 	int i =0;
  45:main.c        **** 	while (( UCSR0A & (1<<UDRE0))  == 0){};
 101               		.loc 1 45 0 discriminator 1
 102 0036 2091 C000 		lds r18,192
 103 003a 25FF      		sbrs r18,5
 104 003c 00C0      		rjmp .L11
 105 003e EC01      		movw r28,r24
 106               	.LVL4:
 107               	.L12:
  46:main.c        ****         while (tab[i] != 0x00)
 108               		.loc 1 46 0
 109 0040 8991      		ld r24,Y+
 110 0042 8823      		tst r24
 111 0044 01F0      		breq .L16
  47:main.c        **** 		{ 
  48:main.c        ****             uart_putchar(tab[i]);
 112               		.loc 1 48 0
 113 0046 0E94 0000 		call uart_putchar
 114               	.LVL5:
 115 004a 00C0      		rjmp .L12
 116               	.L16:
  49:main.c        **** 			i++; 
  50:main.c        ****         }
  51:main.c        **** 		uart_putchar('\n');
 117               		.loc 1 51 0
 118 004c 8AE0      		ldi r24,lo8(10)
 119               	/* epilogue start */
  52:main.c        **** }
 120               		.loc 1 52 0
 121 004e DF91      		pop r29
 122 0050 CF91      		pop r28
  51:main.c        **** }
 123               		.loc 1 51 0
 124 0052 0C94 0000 		jmp uart_putchar
 125               	.LVL6:
 126               		.cfi_endproc
 127               	.LFE3:
 129               	.global	uart_putint
 131               	uart_putint:
 132               	.LFB4:
  53:main.c        **** 
  54:main.c        **** void uart_putint(int value)
  55:main.c        **** {
 133               		.loc 1 55 0
 134               		.cfi_startproc
 135               	.LVL7:
 136 0056 CF93      		push r28
 137               	.LCFI2:
 138               		.cfi_def_cfa_offset 3
 139               		.cfi_offset 28, -2
 140 0058 DF93      		push r29
 141               	.LCFI3:
 142               		.cfi_def_cfa_offset 4
 143               		.cfi_offset 29, -3
 144 005a CDB7      		in r28,__SP_L__
 145 005c DEB7      		in r29,__SP_H__
 146               	.LCFI4:
 147               		.cfi_def_cfa_register 28
 148 005e 6097      		sbiw r28,16
 149               	.LCFI5:
 150               		.cfi_def_cfa_offset 20
 151 0060 0FB6      		in __tmp_reg__,__SREG__
 152 0062 F894      		cli
 153 0064 DEBF      		out __SP_H__,r29
 154 0066 0FBE      		out __SREG__,__tmp_reg__
 155 0068 CDBF      		out __SP_L__,r28
 156               	/* prologue: function */
 157               	/* frame size = 16 */
 158               	/* stack size = 18 */
 159               	.L__stack_usage = 18
  56:main.c        **** 	char tab[16];
  57:main.c        **** 	itoa(value,tab,10);
 160               		.loc 1 57 0
 161 006a 4AE0      		ldi r20,lo8(10)
 162 006c 50E0      		ldi r21,0
 163 006e BE01      		movw r22,r28
 164 0070 6F5F      		subi r22,-1
 165 0072 7F4F      		sbci r23,-1
 166 0074 0E94 0000 		call itoa
 167               	.LVL8:
  58:main.c        **** 	uart_putstring(tab);
 168               		.loc 1 58 0
 169 0078 CE01      		movw r24,r28
 170 007a 0196      		adiw r24,1
 171 007c 0E94 0000 		call uart_putstring
 172               	.LVL9:
 173               	/* epilogue start */
  59:main.c        **** }
 174               		.loc 1 59 0
 175 0080 6096      		adiw r28,16
 176 0082 0FB6      		in __tmp_reg__,__SREG__
 177 0084 F894      		cli
 178 0086 DEBF      		out __SP_H__,r29
 179 0088 0FBE      		out __SREG__,__tmp_reg__
 180 008a CDBF      		out __SP_L__,r28
 181 008c DF91      		pop r29
 182 008e CF91      		pop r28
 183 0090 0895      		ret
 184               		.cfi_endproc
 185               	.LFE4:
 187               	.global	TIM1_Init
 189               	TIM1_Init:
 190               	.LFB5:
  60:main.c        **** 
  61:main.c        **** // ------------------------- END OF UART ----------------------------------------
  62:main.c        **** 
  63:main.c        **** void TIM1_Init()	// enable interrupts
  64:main.c        **** {
 191               		.loc 1 64 0
 192               		.cfi_startproc
 193               	/* prologue: function */
 194               	/* frame size = 0 */
 195               	/* stack size = 0 */
 196               	.L__stack_usage = 0
  65:main.c        ****     OCR1A = ((F_CPU / TIM1_PSC) * TIM1_FREQ) - 1;	// (dec 15624) counter size
 197               		.loc 1 65 0
 198 0092 88E0      		ldi r24,lo8(8)
 199 0094 9DE3      		ldi r25,lo8(61)
 200 0096 9093 8900 		sts 136+1,r25
 201 009a 8093 8800 		sts 136,r24
  66:main.c        ****     TCCR1B |= (1 << WGM12);							// Mode 4, CTC on OCR1A
 202               		.loc 1 66 0
 203 009e E1E8      		ldi r30,lo8(-127)
 204 00a0 F0E0      		ldi r31,0
 205 00a2 8081      		ld r24,Z
 206 00a4 8860      		ori r24,lo8(8)
 207 00a6 8083      		st Z,r24
  67:main.c        ****     TIMSK1 |= (1 << OCIE1A);						// Set interrupt on compare match	
 208               		.loc 1 67 0
 209 00a8 AFE6      		ldi r26,lo8(111)
 210 00aa B0E0      		ldi r27,0
 211 00ac 8C91      		ld r24,X
 212 00ae 8260      		ori r24,lo8(2)
 213 00b0 8C93      		st X,r24
  68:main.c        ****     TCCR1B |= (1 << CS12) | (1 << CS10);			// set prescaler to 1024 and start the timer
 214               		.loc 1 68 0
 215 00b2 8081      		ld r24,Z
 216 00b4 8560      		ori r24,lo8(5)
 217 00b6 8083      		st Z,r24
  69:main.c        ****     sei();	
 218               		.loc 1 69 0
 219               	/* #APP */
 220               	 ;  69 "main.c" 1
 221 00b8 7894      		sei
 222               	 ;  0 "" 2
 223               	/* #NOAPP */
 224 00ba 0895      		ret
 225               		.cfi_endproc
 226               	.LFE5:
 228               	.global	ADC_Init
 230               	ADC_Init:
 231               	.LFB6:
  70:main.c        **** }
  71:main.c        **** 
  72:main.c        **** void ADC_Init()
  73:main.c        **** {
 232               		.loc 1 73 0
 233               		.cfi_startproc
 234               	/* prologue: function */
 235               	/* frame size = 0 */
 236               	/* stack size = 0 */
 237               	.L__stack_usage = 0
  74:main.c        **** 	ADCSRA |= (1 << ADPS2) | (1 << ADPS1) | (1 << ADPS0); // Set ADC prescalar to 128 - 125KHz sample 
 238               		.loc 1 74 0
 239 00bc EAE7      		ldi r30,lo8(122)
 240 00be F0E0      		ldi r31,0
 241 00c0 8081      		ld r24,Z
 242 00c2 8760      		ori r24,lo8(7)
 243 00c4 8083      		st Z,r24
  75:main.c        **** 	ADMUX |= (1 << REFS0); 	// Set ADC reference to AVCC
 244               		.loc 1 75 0
 245 00c6 ACE7      		ldi r26,lo8(124)
 246 00c8 B0E0      		ldi r27,0
 247 00ca 8C91      		ld r24,X
 248 00cc 8064      		ori r24,lo8(64)
 249 00ce 8C93      		st X,r24
  76:main.c        **** 	
  77:main.c        **** 	ADCSRA |= (1 << ADEN);  // Enable ADC
 250               		.loc 1 77 0
 251 00d0 8081      		ld r24,Z
 252 00d2 8068      		ori r24,lo8(-128)
 253 00d4 8083      		st Z,r24
  78:main.c        **** 	ADCSRA |= (1 << ADSC);  // Start A2D Conversions
 254               		.loc 1 78 0
 255 00d6 8081      		ld r24,Z
 256 00d8 8064      		ori r24,lo8(64)
 257 00da 8083      		st Z,r24
  79:main.c        **** 	ADCSRA |= (1 << ADATE);	// for free running mode
 258               		.loc 1 79 0
 259 00dc 8081      		ld r24,Z
 260 00de 8062      		ori r24,lo8(32)
 261 00e0 8083      		st Z,r24
 262 00e2 0895      		ret
 263               		.cfi_endproc
 264               	.LFE6:
 266               		.section	.text.startup,"ax",@progbits
 267               	.global	main
 269               	main:
 270               	.LFB7:
  80:main.c        **** }
  81:main.c        **** 
  82:main.c        **** /*uint16_t ADC_read()			// wykorzystanie pojedynczego pomiaru
  83:main.c        **** {
  84:main.c        **** 	ADCSRA |= (1 << ADSC);		// start ADC conversion
  85:main.c        **** 	while(ADCSRA & (1 << ADSC));
  86:main.c        **** 	return ADCW;
  87:main.c        **** }*/
  88:main.c        **** 
  89:main.c        **** int main(void)
  90:main.c        **** {
 271               		.loc 1 90 0
 272               		.cfi_startproc
 273               	/* prologue: function */
 274               	/* frame size = 0 */
 275               	/* stack size = 0 */
 276               	.L__stack_usage = 0
  91:main.c        **** 	USART_Init(MYUBRR);
 277               		.loc 1 91 0
 278 0000 87E6      		ldi r24,lo8(103)
 279 0002 90E0      		ldi r25,0
 280 0004 0E94 0000 		call USART_Init
 281               	.LVL10:
  92:main.c        **** 	TIM1_Init();
 282               		.loc 1 92 0
 283 0008 0E94 0000 		call TIM1_Init
 284               	.LVL11:
  93:main.c        **** 	ADC_Init();
 285               		.loc 1 93 0
 286 000c 0E94 0000 		call ADC_Init
 287               	.LVL12:
 288               	.L21:
  94:main.c        **** 
  95:main.c        **** 	int ADC_read = 0;
  96:main.c        **** 	double ADC_voltage = 0;
  97:main.c        **** 
  98:main.c        **** 	while(1)
  99:main.c        **** 	{
 100:main.c        **** 		//ADC_voltage = ADC_read*SUPPLY_VOLT/ADC_RES;	// problem z wysylaniem float po UART
 101:main.c        **** 		ADC_read = ADCW;
 289               		.loc 1 101 0 discriminator 1
 290 0010 8091 7800 		lds r24,120
 291 0014 9091 7900 		lds r25,120+1
 292               	.LVL13:
 102:main.c        **** 		//read = ADC_read();	// nie dziala
 103:main.c        **** 		uart_putint(ADC_read);
 293               		.loc 1 103 0 discriminator 1
 294 0018 0E94 0000 		call uart_putint
 295               	.LVL14:
 296 001c 00C0      		rjmp .L21
 297               		.cfi_endproc
 298               	.LFE7:
 300               		.text
 301               	.global	__vector_11
 303               	__vector_11:
 304               	.LFB8:
 104:main.c        **** 	}
 105:main.c        **** }
 106:main.c        **** 
 107:main.c        **** ISR(TIMER1_COMPA_vect)	// timer1 overflow interrupt
 108:main.c        **** {
 305               		.loc 1 108 0
 306               		.cfi_startproc
 307 00e4 1F92      		push r1
 308               	.LCFI6:
 309               		.cfi_def_cfa_offset 3
 310               		.cfi_offset 1, -2
 311 00e6 0F92      		push r0
 312               	.LCFI7:
 313               		.cfi_def_cfa_offset 4
 314               		.cfi_offset 0, -3
 315 00e8 0FB6      		in r0,__SREG__
 316 00ea 0F92      		push r0
 317 00ec 1124      		clr __zero_reg__
 318               	/* prologue: Signal */
 319               	/* frame size = 0 */
 320               	/* stack size = 3 */
 321               	.L__stack_usage = 3
 322               	/* epilogue start */
 109:main.c        **** 
 110:main.c        **** }
 323               		.loc 1 110 0
 324 00ee 0F90      		pop r0
 325 00f0 0FBE      		out __SREG__,r0
 326 00f2 0F90      		pop r0
 327 00f4 1F90      		pop r1
 328 00f6 1895      		reti
 329               		.cfi_endproc
 330               	.LFE8:
 332               	.Letext0:
 333               		.file 2 "/usr/lib/avr/include/stdint.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/cc9su2EU.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cc9su2EU.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cc9su2EU.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cc9su2EU.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc9su2EU.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cc9su2EU.s:12     .text:0000000000000000 USART_Init
     /tmp/cc9su2EU.s:39     .text:0000000000000016 uart_putchar
     /tmp/cc9su2EU.s:61     .text:0000000000000024 uart_getchar
     /tmp/cc9su2EU.s:83     .text:0000000000000032 uart_putstring
     /tmp/cc9su2EU.s:131    .text:0000000000000056 uart_putint
     /tmp/cc9su2EU.s:189    .text:0000000000000092 TIM1_Init
     /tmp/cc9su2EU.s:230    .text:00000000000000bc ADC_Init
     /tmp/cc9su2EU.s:269    .text.startup:0000000000000000 main
     /tmp/cc9su2EU.s:303    .text:00000000000000e4 __vector_11

UNDEFINED SYMBOLS
itoa
